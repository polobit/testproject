package com.campaignio.twitter.util;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.json.JSONObject;

import com.agilecrm.db.ObjectifyGenericDao;
import com.campaignio.tasklets.agile.util.AgileTaskletUtil;
import com.campaignio.twitter.TwitterJob;
import com.campaignio.twitter.TwitterJobQueue;
import com.google.appengine.api.NamespaceManager;

public class TwitterJobQueueUtil
{

    /**
     * Dao for TwitterQueue class
     */
    private static ObjectifyGenericDao<TwitterJobQueue> dao = new ObjectifyGenericDao<TwitterJobQueue>(TwitterJobQueue.class);

    /**
     * Add twitter jobs to twitter queue to post tweets at regular intervals
     * 
     * @param account
     *            Twitter account
     * @param token
     *            Token generated by twitter
     * @param tokenSecret
     *            Token secret generated by twitter
     * @param message
     *            Tweet to be posted
     * @param rateLimit
     *            Number of tweets per hour
     * @param subscriberJSON
     *            Contact data that subscribes to campaign
     * @param campaignJSON
     *            Campaign data
     * @return true if successfully added to queue otherwise false
     */
    public static boolean addToTwitterQueue(String account, String token, String tokenSecret, String message, String rateLimit, JSONObject subscriberJSON,
	    JSONObject campaignJSON)
    {
	// Add to Twitter Queue
	try
	{
	    // Get Existing Queue
	    TwitterJobQueue twitterJobQueue = getTwitterQueueForAccount(account, rateLimit);

	    if (twitterJobQueue == null)
	    {
		twitterJobQueue = new TwitterJobQueue(account, rateLimit);
	    }

	    // Add to Old JSONArray
	    String campaignId = AgileTaskletUtil.getId(campaignJSON);
	    String subscriberId = AgileTaskletUtil.getId(subscriberJSON);
	    TwitterJob twitterJob = new TwitterJob(token, tokenSecret, message, subscriberId, campaignId);
	    twitterJobQueue.twitter_jobs.add(twitterJob);
	    twitterJobQueue.save();

	    return true;

	}
	catch (Exception e)
	{
	    e.printStackTrace();
	}

	return false;
    }

    /**
     * Gets TwitterQueue for an account
     * 
     * @param account
     *            Twitter account
     * @param rateLimit
     *            Number of tweets per hour
     * @return resultant twitter Queue
     */
    public static TwitterJobQueue getTwitterQueueForAccount(String account, String rateLimit)
    {
	String oldNamespace = NamespaceManager.get();
	NamespaceManager.set("");

	Map<String, Object> searchMap = new HashMap<String, Object>();
	searchMap.put("account", account);

	if (!StringUtils.isAlpha(rateLimit))
	    searchMap.put("rate_limit", rateLimit);

	TwitterJobQueue twitterQueue = dao.getByProperty(searchMap);

	NamespaceManager.set(oldNamespace);

	return twitterQueue;
    }

    /**
     * Gets list of twitter Queues with respect to rate limit
     * 
     * @param rateLimit
     *            Tweets limit per hour
     * @return list of twitter queues
     */
    public static List<TwitterJobQueue> getTwitterQueue(String rateLimit)
    {
	String oldNamespace = NamespaceManager.get();
	NamespaceManager.set("");

	List<TwitterJobQueue> twitterQueues = dao.listByProperty("rate_limit", rateLimit);

	NamespaceManager.set(oldNamespace);

	return twitterQueues;
    }

    /**
     * Returns TwitterQueues with respect to namespace.
     * 
     * @param namespace
     *            - namespace.
     * @return TwitterQueue list.
     */
    public static List<TwitterJobQueue> getTwitterQueueForNamespace(String namespace)
    {
	String oldNamespace = NamespaceManager.get();
	NamespaceManager.set("");

	List<TwitterJobQueue> twitterQueues = dao.listByProperty("namespace", namespace);

	NamespaceManager.set(oldNamespace);

	return twitterQueues;
    }

    /**
     * Runs Twitter Queues having specified rate-limit
     * 
     * @param rateLimit
     *            Number of tweets per hour
     */
    public static void runTwitterQueues(String rateLimit)
    {
	// Get All Queues for specified RateLimit
	List<TwitterJobQueue> twitterQueues = getTwitterQueue(rateLimit);

	System.out.println("Tweeting " + twitterQueues.size());

	for (TwitterJobQueue twitterQueue : twitterQueues)
	{
	    // Sets namespace for log.
	    NamespaceManager.set(twitterQueue.namespace);

	    try
	    {
		List<TwitterJob> twitterJobs = twitterQueue.twitter_jobs;

		System.out.println("Queue " + twitterJobs.size());

		// Get First Job, Execute it
		if (twitterJobs.size() > 0)
		{

		    try
		    {
			twitterJobs.get(0).postStatus(twitterJobs.get(0).status);
		    }
		    catch (Exception e)
		    {
			e.printStackTrace();
		    }

		    twitterJobs.remove(0);

		    // Delete the queue for that account if no more jobs are
		    // pending
		    if (twitterJobs.size() == 0)
			twitterQueue.delete();
		    else
		    {
			twitterQueue.twitter_jobs = twitterJobs;
			twitterQueue.save();
		    }
		}

	    }
	    catch (Exception e)
	    {
		e.printStackTrace();
	    }
	}
    }

    /**
     * Deletes campaign from TwitterQueue.
     * 
     * @param campaignId
     *            Campaign ID.
     * @param namespace
     *            namespace.
     */
    public static void removeTwitterJobs(String campaignId, String subscriberId, String namespace)
    {
	List<TwitterJobQueue> twitterQueues = getTwitterQueueForNamespace(namespace);

	if (twitterQueues == null)
	    return;

	for (TwitterJobQueue twitterQueue : twitterQueues)
	{
	    Iterator<TwitterJob> twitterJobIterator = twitterQueue.twitter_jobs.listIterator();

	    while (twitterJobIterator.hasNext())
	    {
		if (!StringUtils.isEmpty(campaignId) && twitterJobIterator.next().campaign_id.equals(campaignId))
		{
		    twitterJobIterator.remove();
		}

		else if (!StringUtils.isEmpty(subscriberId) && twitterJobIterator.next().subscriber_id.equals(subscriberId))
		{
		    twitterJobIterator.remove();
		}
	    }
	    twitterQueue.save();
	}
    }
}
package com.campaignio.twitter.util;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.json.JSONObject;

import com.agilecrm.db.ObjectifyGenericDao;
import com.agilecrm.util.DBUtil;
import com.campaignio.twitter.TwitterJob;
import com.campaignio.twitter.TwitterQueue;
import com.google.appengine.api.NamespaceManager;

public class TwitterQueueUtil
{

    /**
     * Dao for TwitterQueue class
     */
    private static ObjectifyGenericDao<TwitterQueue> dao = new ObjectifyGenericDao<TwitterQueue>(
	    TwitterQueue.class);

    /**
     * Add twitter jobs to twitter queue to post tweets at regular intervals
     * 
     * @param account
     *            Twitter account
     * @param token
     *            Token generated by twitter
     * @param tokenSecret
     *            Token secret generated by twitter
     * @param message
     *            Tweet to be posted
     * @param rateLimit
     *            Number of tweets per hour
     * @param subscriberJSON
     *            Contact data that subscribes to campaign
     * @param campaignJSON
     *            Campaign data
     * @return true if successfully added to queue otherwise false
     */
    public static boolean addToTwitterQueue(String account, String token,
	    String tokenSecret, String message, String rateLimit,
	    JSONObject subscriberJSON, JSONObject campaignJSON)
    {
	// Add to Twitter Queue
	try
	{
	    // Get Existing Queue
	    TwitterQueue twitterQueue = getTwitterQueueForAccount(account,
		    rateLimit);

	    if (twitterQueue == null)
	    {
		twitterQueue = new TwitterQueue(account, rateLimit);
	    }

	    // Add to Old JSONArray
	    String campaignId = DBUtil.getId(campaignJSON);
	    String subscriberId = DBUtil.getId(subscriberJSON);
	    TwitterJob twitterJob = new TwitterJob(token, tokenSecret, message,
		    subscriberId, campaignId);
	    twitterQueue.twitter_jobs.add(twitterJob);
	    twitterQueue.save();

	    return true;

	}
	catch (Exception e)
	{
	    e.printStackTrace();
	}

	return false;
    }

    /**
     * Gets TwitterQueue for an account
     * 
     * @param account
     *            Twitter account
     * @param rateLimit
     *            Number of tweets per hour
     * @return resultant twitter Queue
     */
    public static TwitterQueue getTwitterQueueForAccount(String account,
	    String rateLimit)
    {
	String oldNamespace = NamespaceManager.get();
	NamespaceManager.set("");

	Map<String, Object> searchMap = new HashMap<String, Object>();
	searchMap.put("account", account);

	if (!StringUtils.isAlpha(rateLimit))
	    searchMap.put("rate_limit", rateLimit);

	TwitterQueue twitterQueue = dao.getByProperty(searchMap);

	NamespaceManager.set(oldNamespace);

	return twitterQueue;
    }

    /**
     * Gets list of twitter Queues with respect to rate limit
     * 
     * @param rateLimit
     *            Tweets limit per hour
     * @return list of twitter queues
     */
    public static List<TwitterQueue> getTwitterQueue(String rateLimit)
    {
	String oldNamespace = NamespaceManager.get();
	NamespaceManager.set("");

	List<TwitterQueue> twitterQueues = dao.listByProperty("rate_limit",
		rateLimit);

	NamespaceManager.set(oldNamespace);

	return twitterQueues;
    }

    /**
     * Returns TwitterQueues with respect to namespace.
     * 
     * @param namespace
     *            - namespace.
     * @return TwitterQueue list.
     */
    public static List<TwitterQueue> getTwitterQueueForNamespace(
	    String namespace)
    {
	String oldNamespace = NamespaceManager.get();
	NamespaceManager.set("");

	List<TwitterQueue> twitterQueues = dao.listByProperty("namespace",
		namespace);

	NamespaceManager.set(oldNamespace);

	return twitterQueues;
    }

    /**
     * Runs Twitter Queues having specified rate-limit
     * 
     * @param rateLimit
     *            Number of tweets per hour
     */
    public static void runTwitterQueues(String rateLimit)
    {
	// Get All Queues for specified RateLimit
	List<TwitterQueue> twitterQueues = getTwitterQueue(rateLimit);

	System.out.println("Tweeting " + twitterQueues.size());

	for (TwitterQueue twitterQueue : twitterQueues)
	{
	    try
	    {
		List<TwitterJob> twitterJobs = twitterQueue.twitter_jobs;

		System.out.println("Queue " + twitterJobs.size());

		// Get First Job, Execute it
		if (twitterJobs.size() > 0)
		{

		    try
		    {
			// Sets namespace for log.
			NamespaceManager.set(twitterQueue.namespace);
			twitterJobs.get(0)
				.postStatus(twitterJobs.get(0).status);

			NamespaceManager.set("");
		    }
		    catch (Exception e)
		    {
			e.printStackTrace();
		    }

		    twitterJobs.remove(0);

		    // Delete the queue for that account if no more jobs are
		    // pending
		    if (twitterJobs.size() == 0)
			twitterQueue.delete();
		    else
		    {
			twitterQueue.twitter_jobs = twitterJobs;
			twitterQueue.save();
		    }
		}

	    }
	    catch (Exception e)
	    {
		e.printStackTrace();
	    }
	}
    }

    /**
     * Deletes campaign from TwitterQueue.
     * 
     * @param campaignId
     *            Campaign ID.
     * @param namespace
     *            namespace.
     */
    public static void removeTwitterJobs(String campaignId,
	    String subscriberId, String namespace)
    {
	List<TwitterQueue> twitterQueues = getTwitterQueueForNamespace(namespace);

	if (twitterQueues == null)
	    return;

	for (TwitterQueue twitterQueue : twitterQueues)
	{
	    Iterator<TwitterJob> twitterJobIterator = twitterQueue.twitter_jobs
		    .listIterator();

	    while (twitterJobIterator.hasNext())
	    {
		if (!StringUtils.isEmpty(campaignId)
			&& twitterJobIterator.next().campaign_id
				.equals(campaignId))
		{
		    twitterJobIterator.remove();
		}

		else if (!StringUtils.isEmpty(subscriberId)
			&& twitterJobIterator.next().subscriber_id
				.equals(subscriberId))
		{
		    twitterJobIterator.remove();
		}
	    }
	    twitterQueue.save();
	}
    }
}
